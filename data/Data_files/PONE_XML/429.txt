article id="http://dx.doi.org/10.1371/journal.pone.0170046"  #@NEW_LINE#@#  
title  #@NEW_LINE#@#  
The Potential of Automatic Word Comparison for Historical Linguistics  #@NEW_LINE#@#  

Abstract  #@NEW_LINE#@#  
The amount of data from languages spoken all over the world is rapidly increasing.  #@NEW_LINE#@#  Traditional manual methods in historical linguistics need to face the challenges brought by this influx of data.  #@NEW_LINE#@#  Automatic approaches to word comparison could provide invaluable help to pre-analyze data which can be later enhanced by experts.  #@NEW_LINE#@#  In this way, computational approaches can take care of the repetitive and schematic tasks leaving experts to concentrate on answering interesting questions.  #@NEW_LINE#@#  Here we test the potential of automatic methods to detect etymologically related words (cognates) in cross-linguistic data.  #@NEW_LINE#@#  Using a newly compiled database of expert cognate judgments across five different language families, we compare how well different automatic approaches distinguish related from unrelated words.  #@NEW_LINE#@#  Our results show that automatic methods can identify cognates with a very high degree of accuracy, reaching 89% for the best-performing method Infomap.  #@NEW_LINE#@#  We identify the specific strengths and weaknesses of these different methods and point to major challenges for future approaches.  #@NEW_LINE#@#  Current automatic approaches for cognate detectionalthough not perfectcould become an important component of future research in historical linguistics.  #@NEW_LINE#@#  

Introduction  #@NEW_LINE#@#  
Historical linguistics is currently facing a dramatic increase in digitally available datasets [15].  #@NEW_LINE#@#  The availability of data for more and more languages and language families challenges the ways in which we traditionally compare them.  #@NEW_LINE#@#  The comparative method has been the core method for linguistic reconstruction for the past 200 years [6], and is based on manually identifying systematic phonetic correspondences between many words in pairs of languages.  #@NEW_LINE#@#  However, there are too few expert historical linguists to analyse the worlds more than 7500 languages [7] and, consequently, only a small percentage of these languages have been thoroughly investigated leaving us in the dark about their history and relationships.  #@NEW_LINE#@#  This becomes especially evident in largely understudied linguistic areas like New Guinea, parts of South America, or the Himalayan region, and our lack of knowledge about these languages has immediate implications for our understanding of human prehistory.  #@NEW_LINE#@#  
Over the last two decades computational methods have been become more prevalent in historical linguistics.  #@NEW_LINE#@#  Advocates of computational methods emphasize the speed and replicability as the main advantage of computational techniques [8, 9].  #@NEW_LINE#@#  However, sceptics criticise the validity and accuracy of these methods as lagging far behind those achieved by human experts.  #@NEW_LINE#@#  [10].  #@NEW_LINE#@#  One approach in computational historical linguistics is to design fully-automated methods to identify language relationships with no input from researchers [11, 12].  #@NEW_LINE#@#  Although these methods may provide interesting insights into linguistic macroareas [13], their black-box character makes it difficult to evaluate the results, as judgements about sound correspondences and decisions of cognacy are hidden.  #@NEW_LINE#@#  This opacity makes it difficult to improve the algorithms.  #@NEW_LINE#@#  More problematically, however, it limits the scientific value of these methods, as we do not just want to know how languages are related, but why and which pieces of evidence support this conclusion.  #@NEW_LINE#@#  As a result, there is much suspicion about these methods in historical linguistics [1416].  #@NEW_LINE#@#  
Another approachthe one we take hereis to opt for a computer-assisted framework.  #@NEW_LINE#@#  In contrast to fully automated frameworks, computer-assisted frameworks seek to support and facilitate the task of language comparison by using human expertise where available to correct errors and improve the quality of the results.  #@NEW_LINE#@#  One of the core tasks of the comparative method is the identification of cognate words in multiple languages.  #@NEW_LINE#@#  If two words are cognate, this means that they are genetically related, and have descended from a common ancestor [17].  #@NEW_LINE#@#  Cognate identification, along with the identification of regular sound correspondences, is the basis for proving that two or more languages are genetically related.  #@NEW_LINE#@#  It is also the basis for the reconstruction of ancestral word forms in historically unattested languages, and for the genetic classification of language families.  #@NEW_LINE#@#  In practice, cognate identification is a time-consuming process that is based on an iterative manual procedure where cognate sets are proposed, evaluated, and either kept or rejected [18].  #@NEW_LINE#@#  
This process of manual cognate identification should be an ideal candidate for computer-assisted tasks.  #@NEW_LINE#@#  As a possible workflow, scholars could first run an automatic cognate detection analysis and then edit the algorithmic findings.  #@NEW_LINE#@#  Even an iterative workflow in which the data is passed between computers and experts would be fruitful.  #@NEW_LINE#@#  An important question which arises in this context concerns the quality of automatic methods for cognate detection: Are these methods really good enough to provide concrete help to a highly trained expert?  #@NEW_LINE#@#  In order to find an answer to this question, we tested four publicly available methods and one newly proposed method for automatic cognate detection on six test sets covering five different language families, evaluated the performance of these methods, and determined their shortcomings.  #@NEW_LINE#@#  

Materials_and_Methods  #@NEW_LINE#@#  
Materials  #@NEW_LINE#@#  
There are few datasets available for testing the potential of cognate detection methods on language data, As such, testing algorithms run the risk of over-fitting.  #@NEW_LINE#@#  When developing an algorithm, one usually trains it on some datasets.  #@NEW_LINE#@#  If those datasets are afterwards used to also test the algorithm, the accuracy should be quite high, but we cannot tell whether the method will work on datasets apart from the ones on which the algorithm was trained.  #@NEW_LINE#@#  For this reason, it is important to split the available data into a training set and a test set.  #@NEW_LINE#@#  In our case, the training set will be used to determine the best parameters for each of the algorithms we test, while the test set will be used to carry out the actual test of cognate recovery.  #@NEW_LINE#@#  
For this study, we took training data from existing sources [19], while a new test dataset was compiled from scratch.  #@NEW_LINE#@#  The new test set consists of six datasets from five language families.  #@NEW_LINE#@#  These data were collected from different sources, including published datasets [3, 2023], books [24], and ongoing research by scholars who allowed us to use parts of their data in advance (Uralex project, [25]).  #@NEW_LINE#@#  All datasets were formatted to tabular format and semi-automatically cleaned for various kinds of errors, like misspelled phonetic transcriptions, empty word slots, or obviously erroneous cognate judgments.  #@NEW_LINE#@#  We further linked all languages to Glottolog [7], and all wordlist concepts to the Concepticon [26].  #@NEW_LINE#@#  
Table 1 lists all datasets along with additional details, such as the number of words, concepts, languages, and cognate sets in the data.  #@NEW_LINE#@#  The diversity index given in the last column of the table is calculated by dividing the difference between cognate sets and meanings with the difference between words and meanings [19].  #@NEW_LINE#@#  This score, which ranges between 0 and 1, indicates whether large numbers of words in a given dataset are unrelated (high index) or are cognate (low index).  #@NEW_LINE#@#  As can be seen from the diversity indices listed in the table, our test sets have varying degrees of diversity, ranging from 0.07 (Romance, Saenko, 2015) to 0.57 (Uralic).  #@NEW_LINE#@#  


              https://doi.org/10.1371/journal.pone.0170046.t001  #@NEW_LINE#@#  
As mentioned above, training data is needed for parameter estimation.  #@NEW_LINE#@#  The key parameter we need to estimate is the best thresholds for cognate identification in some of the methods.  #@NEW_LINE#@#  As training data we employed the collection of benchmark datasets for automatic cognate detection by List [19], which also covers six datasets from five language families.  #@NEW_LINE#@#  Details for this dataset (number of words, concepts, languages, cognate sets, and the diversity index) are given in Table 2.  #@NEW_LINE#@#  This dataset is available online at http://dx.doi.org/10.5281/zenodo.11877.  #@NEW_LINE#@#  


              https://doi.org/10.1371/journal.pone.0170046.t002  #@NEW_LINE#@#  

Methods  #@NEW_LINE#@#  
Automatic_Cognate_Detection  #@NEW_LINE#@#  
Many methods for automatic cognate detection have been proposed in the past (see Table 3 below).  #@NEW_LINE#@#  Unfortunately, only a few of these methods qualify as candidate methods for computer-assisted language comparison, since the majority are either (a) not able to analyse multiple languages at once, (b) have further requirements making their use more complicated [31, 32] e.g.  #@NEW_LINE#@#  require a user-specified reference phylogeny (and therefore assume that language groupings are already known), or need extensive training sets, or (c) are not freely available (see Table 3).  #@NEW_LINE#@#  
We decided to take four publicly available methods as the basis of our test study, the Turchin Method, the Edit Distance Method, the SCA Method, and the LexStat Method.  #@NEW_LINE#@#  Additionally, we tested a modified version of the LexStat method which we call Infomap.  #@NEW_LINE#@#  In this modified version of LexStat we introduced an improved partitioning method based on the Infomap algorithm for community detection [33].  #@NEW_LINE#@#  All methods are presented in more detail below.  #@NEW_LINE#@#  
The four publicly available methods are all implemented as part of the same software package (LingPy, http://lingpy.org, [42]), and represent different degrees of algorithmic sophistication and closeness to linguistic theory, with the Turchin Method being very simple and computationally extremely fast, and the LexStat Method being rather complex and time-consuming.  #@NEW_LINE#@#  For the usage of the fifth method, we wrote a small LingPy plugin which builds on the python-igraph package (http://igraph.org/python-igraph/, [43], see details below) and is provided along with our supplementary material.  #@NEW_LINE#@#  

Cognate_Detection_following_Turchin_et_al_[44]  #@NEW_LINE#@#  
The Turchin method (also called Consonant Class Matching approach) was proposed by Turchin et al.  #@NEW_LINE#@#  [44].  #@NEW_LINE#@#  In this method, the consonants of the words are converted to one of 10 possible consonant classes.  #@NEW_LINE#@#  The idea of consonant classes (also called sound classes) was proposed by Dolgopolsky [45], who stated that certain sounds occur more frequently in correspondence relation than others and could therefore be clustered into classes of high historical similarity.  #@NEW_LINE#@#  In the approach by Turchin et al., two words are judged to be cognate, if they match in their first two consonant classes.  #@NEW_LINE#@#  

Cognate_Detection_using_the_Edit_Distance_approach  #@NEW_LINE#@#  
A second method provided by LingPy, the Edit Distance approach, takes the normalized Levenshtein distance [46], between all word pairs in the same meaning slot and clusters these words into potential cognate sets using a flat version of the UPGMA algorithm [47] which terminates once a certain threshold of average distances between all words is reached.  #@NEW_LINE#@#  This general procedure of flat clustering, which is also employed for the two remaining cognate detection methods provided by LingPy, is illustrated in Fig 1A and 1B.  #@NEW_LINE#@#  

Cognate_Detection_using_the_Sound_Class_Algorithm  #@NEW_LINE#@#  
A third method available in the LingPy package, the SCA method, uses the same threshold-based clustering algorithm as the Edit Distance but employs distance scores derived from the Sound-Class Based Alignment (SCA) method [19].  #@NEW_LINE#@#  This method for pairwise and multiple alignment analyses uses expanded sound class models along with detailed scoring functions as its basis.  #@NEW_LINE#@#  In contrast to previous alignment algorithms [48], the SCA algorithm takes prosodic aspects of the words into account and is also capable of aligning within morpheme boundaries, if morpheme information is available in the input data [19].  #@NEW_LINE#@#  

Cognate_Detection_using_the_LexStat_method  #@NEW_LINE#@#  
The last publicly available method we tested, the LexStat method, is again based on flat UPGMA clustering, but in contrast to both the Edit-Distance method and the SCA method, it uses language-specific scoring schemes which are derived from a Monte-Carlo permutation of the data [19].  #@NEW_LINE#@#  This permutation, by which the wordlists of all language pairs are shuffled in such a way that words denoting different meanings are aligned and scored, is used to derive a distribution of sound-correspondence frequencies under the assumption that both languages are not related.  #@NEW_LINE#@#  The permuted distribution is then compared with the attested distribution, and converted into a language-specific scoring scheme for all language pairs.  #@NEW_LINE#@#  Using this scoring scheme, the words in the data are aligned again, and distance scores are derived which are then used as the basis for the flat cluster algorithm.  #@NEW_LINE#@#  

Differences_between_algorithms  #@NEW_LINE#@#  
In order to illustrate the differences between these four algorithms, we analysed the test set by Kessler [49].  #@NEW_LINE#@#  This dataset is particularly interesting for the task of cognate detection, since the sample of languages contains not only four Indo-European languages with different degrees of genetic affiliation, but also unrelated languages from different language families.  #@NEW_LINE#@#  When running the algorithm with default thresholds as proposed in List [19], LexStat performs best, showing the smallest amount of false positives and false negatives, followed by SCA, Edit-Distance, and Turchin.  #@NEW_LINE#@#  When looking at specific results of this analysis, like the cognate judgments for the concept there, given in Table 4, for example, we can immediately see the shortcomings of the language-independent methods.  #@NEW_LINE#@#  The Turchin method (T), for example, links Albanian [aty] and Navajo [adi] as cognate, where these are a clear chance resemblance in the consonant class structure.  #@NEW_LINE#@#  Note that initial vowel is treated identical with initial glottal stop in the Turchin method, following the original sound class proposal by [45].  #@NEW_LINE#@#  
The Edit Distance (E) method also identifies a chance resemblance by proposing that French [la] and Hawaian [laila] are cognate.  #@NEW_LINE#@#  The Edit-Distance method is especially prone to identifying chance similarity as cognacy, and this risk increases as languages get more and more different [15].  #@NEW_LINE#@#  The threshold of the SCA method (S) is too low to identify any cognate set for the concept there.  #@NEW_LINE#@#  Only the LexStat method (L) correctly identifies English [รฐr] and German [da] as cognates, but not due to the phonetic similarity of the words, but due to the fact that matches of English [รฐ] and German [d] recur frequently in the dataset.  #@NEW_LINE#@#  

Similarity_Networks  #@NEW_LINE#@#  
All the above cognate detection methods currently use a rather simple flat clustering procedure.  #@NEW_LINE#@#  The basis of this procedure is a clustering algorithm which terminates when average distances among sequences exceed a certain threshold.  #@NEW_LINE#@#  In evolutionary biology, the task of homolog detection is often approached from a network perspective.  #@NEW_LINE#@#  In similarity networks, for example, gene or protein sequences are modeled as the nodes of a network, and edges between the nodes are drawn with weights representing the pairwise similarities [50, 51].  #@NEW_LINE#@#  Homolog detection is then modeled as a network partitioning task by which the network is divided into subgraphs with some objective criterion being used to define the best partition of the original network.  #@NEW_LINE#@#  While originally developed for the application in evolutionary biology, sequence similarity networks are now increasingly being tested on linguistics data [52, 53] and it was proposed that they might not only help to detect both genetically related words as well as words which have been borrowed [54].  #@NEW_LINE#@#  Many strategies for network partitioning exist.  #@NEW_LINE#@#  The most common methods used in biology are Markov Clustering [55], k-means [56], and Affinity Propagation [57].  #@NEW_LINE#@#  k-means has the strong disadvantage that it requires that the number of clusters into which the data shall be partitioned needs to be specified in advance.  #@NEW_LINE#@#  Tests in evolutionary biology have further shown that Markov Clustering outperforms Affinity Propagation [58].  #@NEW_LINE#@#  This finding suggests that Markov Clustering would be an ideal choice for linguistic applications.  #@NEW_LINE#@#  However, when testing the approach on our training data, the results were inconclusive, and no real improvement compared with the default clustering algorithm used in LingPy could be observed.  #@NEW_LINE#@#  
For this study, we followed List et al.  #@NEW_LINE#@#  [53] in testing a partitioning approach which was originally developed for the task of community detection in social network analysis [59] and has shown to perform with a high accuracy: The Infomap algorithm [33] uses random walks to identify the best way to assign the nodes in a network to distinct communities.  #@NEW_LINE#@#  In order to convert the matrix of pairwise distances between words into a graph, we first define a threshold, and then add edges between all words whose pairwise distance is below the threshold.  #@NEW_LINE#@#  The edge weight is the distance score converted to a similarity score by subtracting it from 1.  #@NEW_LINE#@#  We use the pairwise distance matrices produced by the LexStat method, since this was shown to outperform the other three methods implemented in LingPy [19].  #@NEW_LINE#@#  How cognate detection is modeled as a graph partitioning problem applied to similarity networks is displayed in more detail in Fig 1C and 1D.  #@NEW_LINE#@#  

Evaluation  #@NEW_LINE#@#  
It is not necessarily an easy task to compare how well an algorithm for automatic cognate detection performs in comparison with a gold standard.  #@NEW_LINE#@#  In our study, our gold standard are the expert cognate decisions by historical linguists using the comparative method.  #@NEW_LINE#@#  Scholars often use pairwise scores [32] for evaluation.  #@NEW_LINE#@#  In these scores, all words in a concept slot are assembled into pairs.  #@NEW_LINE#@#  The pair score is then calculated by comparing how many pairs in the gold standard are identically clustered by the algorithm, and vice versa.  #@NEW_LINE#@#  This is simple and straightforward, since, for pairs, there are only two possible decisions, namely whether they are cognate or not.  #@NEW_LINE#@#  We can then simply count how many pairs in the gold standard are also judged to be cognate by the algorithm, or how many pairs proposed to be cognate by the algorithm are also cognate according to the gold standard.  #@NEW_LINE#@#  The advantage of this score is that we can directly convert it into an intuitive notion of false positives and false negatives versus true positives and true negatives.  #@NEW_LINE#@#  
Breaking down the comparison of two different clusters into pairs is, however, problematic, since it has a strong bias in favoring datasets containing large amounts of non-cognate words [19].  #@NEW_LINE#@#  In order to avoid these problems, we used B-Cubed scores as our primary evaluation method [37, 60, 61].  #@NEW_LINE#@#  For the calculation of B-Cubed scores, we need to determine for each of the words the intersection of words between its cognate set in the gold standard and its cognate set proposed by the algorithm, as well as the size of the respective cognate sets.  #@NEW_LINE#@#  This is illustrated in Table 5 for a fictive test analysis of the five words in Fig 1, which wrongly clusters the Greek word with the English and the German word.  #@NEW_LINE#@#  For the B-Cubed precision we then average the size of the intersection divided by the size of the cognate set proposed by the algorithm for each of the words in our sample:  #@NEW_LINE#@#  
(1)  #@NEW_LINE#@#  
For the B-Cubed recall we average the intersection size divided by the cognate set size in the gold standard:  #@NEW_LINE#@#  
(2)  #@NEW_LINE#@#  
The B-Cubed F-Score is then computed as usual:  #@NEW_LINE#@#  
(3)  #@NEW_LINE#@#  


Threshold_and_Parameter_Selection  #@NEW_LINE#@#  
Apart from the Turchin method, all analyses require a threshold which ranges between 0 and 1, denoting the amount of similarity needed to judge two items as cognate.  #@NEW_LINE#@#  In order to find the most suitable threshold for each of the three methods, we used the expert cognate decisions in our training set and ran the analyses on these data with varying thresholds starting from 0.05 up to 0.95.  #@NEW_LINE#@#  Fig 2 shows box-plots of the training analyses for the four methods, depending on the threshold.  #@NEW_LINE#@#  As can be seen from this figure, all methods show a definite peak where they yield the best results for all datasets.  #@NEW_LINE#@#  In order to select the best threshold for each of the four methods, we selected the threshold which showed the best average B-Cubed F-Score (i.e.  #@NEW_LINE#@#  the best accuracy at recovering the known cognate sets).  #@NEW_LINE#@#  For the Edit Distance Method, the threshold was thus set to 0.75, for the SCA Method it was set to 0.45, for the LexStat Method, it was set to 0.60, and for the Infomap method, it was set to 0.55.  #@NEW_LINE#@#  The B-Cubed scores for these analyses are given in Table 6.  #@NEW_LINE#@#  These results indicate that the Infomap method performs best, followed by LexStat and SCA.  #@NEW_LINE#@#  Of the two worst-performing methods, the Turchin method performs worst in terms of F-Scores, but shows a much higher precision than the Edit-Distance method.  #@NEW_LINE#@#  
The y-axis shows the B-Cubed F-scores averaged over all training sets, and the x -axis shows the threshold for the 5 methods we tested.  #@NEW_LINE#@#  Infomap shows the best results on average, Edit Distance performs worst.  #@NEW_LINE#@#  Dots in the plots indicate the mean for each sample, with triangular symbols indicating the peak.  #@NEW_LINE#@#  


              https://doi.org/10.1371/journal.pone.0170046.g002  #@NEW_LINE#@#  
Bold numbers indicate best values.  #@NEW_LINE#@#  


              https://doi.org/10.1371/journal.pone.0170046.t006  #@NEW_LINE#@#  


Results  #@NEW_LINE#@#  
We analyzed the datasets with each of the five methods described above, using the individual thresholds for each method, setting the number of permutations to 10,000, and using the default parameters in LingPy.  #@NEW_LINE#@#  For each analysis, we further calculated the B-Cubed scores to evaluate the performance of each method on each dataset.  #@NEW_LINE#@#  
Table 7 shows the averaged results of our experiments.  #@NEW_LINE#@#  While the LexStat method shows the highest precision, the Infomap method shows the highest recall and also the best general performance.  #@NEW_LINE#@#  The results are generally consistent with those reported by List [19] for the performance of Turchin, Edit Distance, SCA, and LexStat: The Turchin method is very conservative with a low amount of false positives as reflected by the high precision, but a very large amount of undetected cognate relations as reflected by the low recall.  #@NEW_LINE#@#  The Edit Distance method shows a much higher cognate detection rate, but at the cost of a high rate of false positives.  #@NEW_LINE#@#  The SCA method outperforms the Edit Distance, thus showing that refined distance scores can make a certain difference in automatic cognate detection.  #@NEW_LINE#@#  


              https://doi.org/10.1371/journal.pone.0170046.t007  #@NEW_LINE#@#  
However, as the performance of LexStat and Infomap shows: Language-specific approaches for cognate detection clearly outperform language-independent approaches.  #@NEW_LINE#@#  The reason for this can be found in the specific similarity measure that is employed by the methods: the better performing methods are not based on surface similarities, but on similarities derived from previously inferred probability scores for sound correspondences.  #@NEW_LINE#@#  These methods are therefore much closer to the traditional comparative method than methods which employ simple surface similarities between sounds.  #@NEW_LINE#@#  Our experiment with the Infomap algorithm shows that a shift from simple agglomerative clustering approaches to a network perspective may further strengthen the results.  #@NEW_LINE#@#  Similarity networks have been successfully employed in evolutionary biology for some time now and should now become a fruitful topic of research in computational historical linguistics as well.  #@NEW_LINE#@#  
Dataset_Specific_Results  #@NEW_LINE#@#  
There are interesting differences between method performance across language datasets, with marked variation in cognate identification accuracy between different languages.  #@NEW_LINE#@#  Fig 3 shows the performance of the methods on the individual test sets, indicating which method performed best and which method performed worst.  #@NEW_LINE#@#  These results confirm the high accuracy of the LexStat method and the even better accuracy of the Infomap approach.  #@NEW_LINE#@#  All methods apart from the Turchin method perform the worst on the Chinese data.  #@NEW_LINE#@#  Since compounding is very frequent in Chinese, it is difficult to clearly decide which words to assign to the same cognate set.  #@NEW_LINE#@#  Often, words show some overlap of cognate material without being entirely cognate.  #@NEW_LINE#@#  This is illustrated in Fig 4, where cognates and partial cognates for Germanic and Sinitic languages are compared.  #@NEW_LINE#@#  We followed a strict procedure by which only words in which all morphemes are cognate are labelled as cognate [62], rather than loosely placing all words sharing a single cognate morpheme in the same cognate set [63].  #@NEW_LINE#@#  Since neither of the algorithms we tested is specifically sensitive for partial cognate relations (for a recent proposal for this task, see [53]), they all show a very low precision, because they tend to classify only partially related words as fully cognate.  #@NEW_LINE#@#  
The figure shows the individual results of all algorithms based on B-Cubed F-Scores for each of the datasets.  #@NEW_LINE#@#  Results marked by a red triangle point to the worst result for a given subset, and results marked by a yellow star point to the best result.  #@NEW_LINE#@#  Apart from Uralic, our new Infomap approach always performs best, while the Turchin approach performs worst in four out of six tests.  #@NEW_LINE#@#  


              https://doi.org/10.1371/journal.pone.0170046.g003  #@NEW_LINE#@#  
The word for moon in Germanic and Sinitic languages is mono-morphemic in Germanic languages, while it is usually compounded in Chinese dialects, with the first element in the compound meaning moon proper, while the second often originally meant shine or glance.  #@NEW_LINE#@#  The different cognate relations among the morphemes in the Chinese words make it impossible to give a binary assessment regarding the cognacy of the four words.  #@NEW_LINE#@#  


              https://doi.org/10.1371/journal.pone.0170046.g004  #@NEW_LINE#@#  
The Turchin method has three extreme outliers in which it lags far behind the other methods: Chinese, Bahnaric and Romance.  #@NEW_LINE#@#  There are two major reasons for this.  #@NEW_LINE#@#  First, the Turchin method only compares the first two consonants and will be seriously affected by the problem of partial cognates discussed above.  #@NEW_LINE#@#  These partial cognates are especially prevalent in Chinese and Bahnaric where compounding is an important linguistic process.  #@NEW_LINE#@#  Second, a specific weakness of the Turchin method is the lack of an alignment and words are not exhaustively compared for structural similarities but simply mapped in their first two initial consonants.  #@NEW_LINE#@#  When there is substantial sound change, as is evident in both Bahnaric and some branches of Romance, this may lead to an increased amount of false negatives.  #@NEW_LINE#@#  Since the Turchin method only distinguishes 10 different sound classes and only compares the first two consonant classes in each word in the data, it is very likely to miss obvious cognates.  #@NEW_LINE#@#  The main problem here is that the method does not allow for any transition probabilities between sound classes, but treats them as discrete units.  #@NEW_LINE#@#  As a result, it is likely that the Turchin method often misses valid cognate relations which are easily picked up by the other methods.  #@NEW_LINE#@#  This shortcoming of the Turchin approach is illustrated in Fig 5, where the amount of true positives and negatives is contrasted with the amount of false positives and negatives in each dataset and for each of the five methods.  #@NEW_LINE#@#  This figure indicates that the Turchin method shows exceptionally high amounts of false negatives in Bahnaric and Romance.  #@NEW_LINE#@#  The clear advantage of the Turchin method is its speed, as it can be computed in linear time.  #@NEW_LINE#@#  Its clear disadvantage is its simplicity which may under certain circumstances lead to a high amount of false negatives.  #@NEW_LINE#@#  


              https://doi.org/10.1371/journal.pone.0170046.g005  #@NEW_LINE#@#  
The Edit-Distance method also performs very poorly.  #@NEW_LINE#@#  While, on average, it performs better than the Turchin approach, it performs considerably worse on the Chinese and Huon test sets.  #@NEW_LINE#@#  The reason for this poor performance can be found in a high amount of false positives as shown in Fig 5.  #@NEW_LINE#@#  While the Turchin method suffers from not finding valid cognates, the Edit-Distance method suffers from the opposite problemidentifying high amounts of false cognates.  #@NEW_LINE#@#  Since false positives are more deleterious for language comparison, as they might lead to false conclusions about genetic relationship [15], the Edit-Distance method should be used with very great care.  #@NEW_LINE#@#  Given that the SCA method performs better while being similarly fast, there is no particular need to use the Edit-Distance method at all.  #@NEW_LINE#@#  
In Fig 6, we further illustrate the difference between the worst and the best approaches in our study by comparing false positives and false negatives in Turchin and Infomap across all language pairs in the Chinese data.  #@NEW_LINE#@#  As can be seen from Fig 5, the Turchin approach has about as many false positives as false negatives.  #@NEW_LINE#@#  The Infomap approach shows slightly more false positives than false negatives.  #@NEW_LINE#@#  This general picture, however, changes when looking at the detailed data plotted in Fig 6.  #@NEW_LINE#@#  Here, we can see that false positives in the Turchin approach occur in almost all dialect pairings, while the major number of cognates is missed in the mainland dialects (bottom of the y-axis).  #@NEW_LINE#@#  Infomap, on the other hand, shows drastically fewer false positives and false negatives, but while false negatives can be mostly observed in the Northern dialects (bottom of y-axis), false positives seem to center around the highly diverse Southern dialects (top of the y-axis).  #@NEW_LINE#@#  This reflects the internal diversity in Northern and Southern Chinese dialects, and the challenges resulting from it for automatic cognate detection.  #@NEW_LINE#@#  While word compounding is very frequent in the North of China, where almost all words are bisyllabic and bimorphemic, the Southern dialects often preserve monosyllabic words.  #@NEW_LINE#@#  While Northern dialects are rather homogeneous, showing similar sound systems and a rather large consonant inventories, Southern dialects have undergone many consonant mergers in their development, and are highly diverse.  #@NEW_LINE#@#  The unique threshold for cognate word detection overestimates similarities among the Southern dialects (upper triangle, left quarter), while it underestimates similarities among Northern dialects compared to Southern dialects (lower triangle, left quarter).  #@NEW_LINE#@#  What further contributes to this problem is also the limited size of the word lists in our sample, which make it difficult for the language-specific algorithms to acquire enough deep signal.  #@NEW_LINE#@#  
The figure compares the amount of false positives and false negatives, as measured in pairwise scores for the Turchin method and our Infomap approach for all pairs of language varieties in the Chinese test set.  #@NEW_LINE#@#  The upper triangle of the heatmaps shows the amount of false positives, while the lower triangle shows the amount of false negatives.  #@NEW_LINE#@#  


              https://doi.org/10.1371/journal.pone.0170046.g006  #@NEW_LINE#@#  


Discussion  #@NEW_LINE#@#  
In this study we have applied four published methods and one new method for automated cognate detection to a set of six different test sets from five different language families.  #@NEW_LINE#@#  By training our data on an already published dataset of similar size, we identified the best thresholds to obtain a high accuracy for detecting truly related words for four out of the five methods (Edit-Distance: 0.75, SCA: 0.45, LexStat: 0.6, Infomap: 0.55).  #@NEW_LINE#@#  Using these thresholds, we tested the methods on our new gold standard, and found that most methods identified cognates with a considerable amount of accuracy ranging from 0.82 (Tuchin) to 0.89 (Infomap).  #@NEW_LINE#@#  Our new method, which builds on the LexStat method but employs the Infomap algorithm for community detection to partition words into cognate sets, outperforms all other methods in almost all regards, slightly followed by the LexStat approach.  #@NEW_LINE#@#  Given that the LexStat method and our Infomap approach are based on language-specific language comparison, searching for similar patterns in individual language pairs, our results confirm the superiority of cognate detection approaches which are closer to the theoretical foundation of the classical comparative method in historical linguistics.  #@NEW_LINE#@#  The Consonant Class Matching method by Turchin et al.  #@NEW_LINE#@#  confirmed worst in our experiment, followed by the Edit-Distance approach, which was criticized in earlier work [15].  #@NEW_LINE#@#  While the major drawback of the Turchin approach is a rather large amount of false negatives, the Edit-Distance approach shows the highest amount of false positives in our test.  #@NEW_LINE#@#  
The method of choice may well depend on the task to which cognate detection is to be applied.  #@NEW_LINE#@#  If the task is to simply identify some potential cognates for future inspection and annotation, then a fast algorithm like the one by Turchin et al.  #@NEW_LINE#@#  should provide enough help to get started.  #@NEW_LINE#@#  This practice, which is already applied by some scholars [64], is further justified by the rather small amount of false positives.  #@NEW_LINE#@#  While the use of the Turchin method may be justified in computer-assisted workflows, the use of the Edit-Distance approach should be discouraged, since it lacks the speed advantages and is very prone to false positives.  #@NEW_LINE#@#  
When searching for deeper signals in larger datasets, however, we recommend using the more advanced methods, like SCA, LexStat or our new Infomap approach.  #@NEW_LINE#@#  LexStat and Infomap have the great advantage of taking regular sound correspondences into account.  #@NEW_LINE#@#  As a result, these methods tend to refuse chance resemblances and borrowings.  #@NEW_LINE#@#  Their drawback is the number of words needed to carry out the analysis.  #@NEW_LINE#@#  As we know from earlier tests [65], language-specific methods require at least 200 words for moderately closely related languages.  #@NEW_LINE#@#  When applied to datasets with higher diversity among the languages, the number of words should be even higher.  #@NEW_LINE#@#  Thus, when searching for cognates in very short word lists, we recommend using the SCA method to achieve the greatest accuracy.  #@NEW_LINE#@#  However, as demonstrated by the poorer performance of all methods on the Chinese language data where compounding has played a major role in word formation, language family specific considerations about the methods and processes need to be taken into consideration.  #@NEW_LINE#@#  
Our results show that the performance of computer-assisted automatic cognate detection methods has advanced substantially, both with respect to the applicability of the methods and the accuracy of the results.  #@NEW_LINE#@#  Moreover, given that the simple change we made from agglomerative to network-based clustering could further increase the accuracy of the results, shows that we have still not exhausted the full potential of cognate detection methods.  #@NEW_LINE#@#  Future algorithms may bring us even closer to experts judgments, and it seems worthwhile to invest time to increase the performance of our algorithms.  #@NEW_LINE#@#  Essential tasks for the future include (a) the work on parameter-free methods which do not require user-defined thresholds and state the results as probabilities rather as binary decisions, (b) the further development of methods for partial cognate detection [53], (c) approaches that search for cognates not only in the same meaning slot but across different meanings [66], and (d) approaches that integrate expert annotations to allow for a true iterative workflow for computer-assisted language comparison.  #@NEW_LINE#@#  A key problem to solve is the performance of these methods on larger datasets that trace language relationships to a greater depth.  #@NEW_LINE#@#  Most of our test cases in this paper are shallow families or subgroups of larger families.  #@NEW_LINE#@#  Deeper relationships between languages spoken in more complicated language situations are where the real challenge lies.  #@NEW_LINE#@#  
Currently automatic cognate detection algorithms are highly accurate at detecting a substantial proportion of the cognates in a lexical dataset.  #@NEW_LINE#@#  Tools like LingPy are already at a stage where they can act as a computer-assisted framework for language comparison.  #@NEW_LINE#@#  These tools therefore provide a powerful way of supplementing the historical linguistics toolkit by enabling linguists to rapidly identify the cognate sets which can then be checked, corrected, and augmented as necessary by experts.  #@NEW_LINE#@#  In regions where there has been an absence of detailed historical comparative work, these automated cognate assignments can provide a way to pre-process linguistic data from less well studied languages and speed up the process by which experts apply the comparative method.  #@NEW_LINE#@#  Additionally, these tools can be employed for exploratory data analysis of larger datasets, or to arrive at preliminary classifications for language families which have not yet been studied with help of the classical methods.  #@NEW_LINE#@#  

Acknowledgments  #@NEW_LINE#@#  
We thank the anonymous reviewers for helpful advice.  #@NEW_LINE#@#  We thank Outi Vesakoski and Jury Lehtinen (Uralic data from the Uralex project), Paul Sidwell (Bahnaric), George Starostin (Tujia), and M. Saenko (Romance) for sharing their data with us by either exchanging them directly or making them accessible online.  #@NEW_LINE#@#  

Author_Contributions  #@NEW_LINE#@#  


Conceptualization: JML SJG RDG.  #@NEW_LINE#@#  
Data curation: JML.  #@NEW_LINE#@#  
Formal analysis: JML SJG.  #@NEW_LINE#@#  
Funding acquisition: SJG RDG.  #@NEW_LINE#@#  
Investigation: JML SJG.  #@NEW_LINE#@#  
Methodology: JML SJG.  #@NEW_LINE#@#  
Project administration: RDG.  #@NEW_LINE#@#  
Software: JML.  #@NEW_LINE#@#  
Validation: JML SJG RDG.  #@NEW_LINE#@#  
Visualization: JML SJG.  #@NEW_LINE#@#  
Writing  original draft: JML.  #@NEW_LINE#@#  
Writing  review & editing: JML SJG RDG.  #@NEW_LINE#@#  



References  #@NEW_LINE#@#  


